# 引言

*****

​	C++的底层编译为了与C兼容，继承了C语言编译的大部分特点，所以在了解C++的底层编译原理之前，有必要好好聊聊C的编译模型。

​	众所周知C语言产生于贝尔实验室，当时的计算机资源相当有限，其内存无法完成地表示单个源文件的语法树，所以为了能够编译一些工程量较大的项目，**Dennis Ritchie**采用了分开编译源文件，链接形成可执行文件思想，让大文件的编译成为可能。

​	早期的C语言编译器并不是一个单独的程序(现在的编译器也很多是由单独功能的程序模块组成的编译工具链)，**Dennis Ritchie**为**PDP-11**编写的C语言编译器是七个可执行文件组成的：**cc**/**cpp**/**as**/**ld**/**c0**/**c1**/**c2**。编译的步骤为:

- 预编译：将#define，#Include这些的宏定义进行展开 cpp是预处理器
- 编译：将源代码转化汇编代码 (由c0 c1 c2完成)
- 汇编：as是汇编器，将汇编代码转化为目标文件,其外，该步骤还会产生一个符号表，记录每个文件符号的位置，如果当时无法知道该符号的位置，就先打上条目，由链接器去查找。
- 链接：ld 是连接器，将多个源文件链接成可执行文件

符号表的生成：

每个文件的符号主要有三类：

1. 在该文件定义的可以被其他文件引用的，如函数，全局变量
2. 在该文件定义的不可以被其他文件引用的，如果static修饰的函数，局部变量
3. 不在该文件定义的，从其他文件引用过来的，如extern 声明的变量，函数声明式.

前俩位符号，符号表可以直接找到该符号的位置，但是第三类符号需要在连接时由链接器定位其具体的位置。

# C编译模型

------

​	由前言我们可以知道，C语言由于内存受限采用了分离编译的做法，为了对分离编译提供支持，C语言的编译模型具有以下特点。

1. 隐式函数声明：在一个文件可以进行函数的声明而不实现该函数，在编译期间，编译器会为其生成目前代码(将函数入栈，记录函数的参数个数以及类型，返回值类型)，但是其无法知道该函数的具体地址，所以生成的符号表会打个空白，等到链接时再去找到该函数。
2. 单遍编译：C语言的编译是边扫描源文件，边生成目标代码，而且其由于内存的限制，C语言只能看到当前已经解析过的代码，无法看到之后的，而且不会保存所有已经扫描过的内容，会过目即忘。因此熟悉C语言的同学会发现C语言有以下的严格定义：
   - 变量必须先定义后使用，这样在后续使用该变量时，编译器才能知道清楚地知道变量位于哪个stack，位于其哪个位置，什么类型
   - C语言编译要求变量必须定义在函数的最开头，这是为了方便编译器分配stack空间
   - C语言的结构体必须先定义才能访问其成员，不然编译器无法知道结构体成员的类型以及偏移量
   - 遇到没定义过的函数采用隐式函数声明的方式
   - C语言不支持函数内部嵌套定义函数，多嵌套一次函数就需要多分配一个栈，内存占用会更多。

# C++的编译模型

----

​	C++为了兼容C的编译模型，采用类似单遍编译的做法，回忆以下单边扫描的特点：从头到尾扫描，边扫描边生成。

​	这种方式存在着俩个问题：

1. 函数重载：如何去找到最合适的那个函数，是使用当前已经找到的函数还是先保存当前去查看后面是否存在更加匹配的函数。

2. 多值查找：C++存在着template这一复杂的函数声明，如何在编译时正确地找出其对应的符号，同时，当存在多个定义时，如果确保正确地找出对应的符号。	



   ​	C++实际上并不是单边编译，而是伪单边编译，其实际上会遍历2遍源代码进行编译，但是对外表现出单边编译。

   ​	为了实现函数重载，C++编译器采用名字修饰(name mining **名字修饰**) 的方法，即一个函数对应于一个符号，重载的函数会生成不同的函数符号。

   ​	在C语言中通常一个符号在程序中只能有一处定义，不然就会造成重定义，但是C++并非如此，C++在编译时，并不知道某些符号是否由该文件产生，因此每个目标文件都会生成一份弱定义，由编译器去选择哪一份作为最终的定义。

   ## 名字修饰

   ### 简单样例

   考虑一个下面的C++程序中的两个`f()`的定义：

   ```C++
   int  f (void) { return 1; }
   int  f (int)  { return 0; }
   void g (void) { int i = f(), j = f(0); }
   ```

   这些是不同的函数，除了函数名相同以外没有任何关系。如果不做任何改变直接把它们当成C代码，结果将导致一个错误——C语言不允许两个函数同名。所以，C++编译器将会把它们的类型信息编码成符号名，结果类似下面的的代码：

   ```C++
   int  __f_v (void) { return 1; }
   int  __f_i (int)  { return 0; }
   void __g_v (void) { int i = __f_v(), j = __f_i(0); }
   ```

   注意`g()`也被名字修饰了，虽然没有任何名字冲突。名字修饰应用于C++的任何符号。

   ### 从C++中链接时的C符号的处理

   最常见的C++惯常的做法：

   ```C++
   #ifdef __cplusplus 
   extern "C" {
   #endif
       /* ... */
   #ifdef __cplusplus
   }
   #endif
   ```

   这种写法用于确保下符号是未被C++编译器名字修饰过的——这种代码能使得C++编译器编译出的二进制目标代码中的链接符号是未经过C++名字修饰过的，就像C编译器一样。就像C语言定义是未名字修饰过的一样，C++编译器需要防止名字修饰这些标识符。

   例如，C标准字符串库`<string.h>`通常包含了类似这样子的

   ```C++
   #ifdef __cplusplus
   extern "C" {
   #endif
   
   void *memset (void *, int, size_t);
   char *strcat (char *, const char *);
   int   strcmp (const char *, const char *);
   char *strcpy (char *, const char *);
   
   #ifdef __cplusplus
   }
   #endif
   ```

   于是，例如这样的代码

   ```c++
   if (strcmp(argv[1], "-x") == 0) 
       strcpy(a, argv[2]);
   else 
       memset (a, 0, sizeof(a));
   ```

   就能使用正确的、未经名字修饰过的`strcmp`和`memset`。如果没有使用`extern "C"`，那么SunPro C++编译器会产生等价于下面的C代码：

   ```C++
   if (__1cGstrcmp6Fpkc1_i_(argv[1], "-x") == 0) 
       __1cGstrcpy6Fpcpkc_0_(a, argv[2]);
   else 
       __1cGmemset6FpviI_0_ (a, 0, sizeof(a));
   ```

   而这些链接符号并不存在于C运行库中（*例如* `libc`）。因此将导致链接错误。



# 